# coding: utf-8

"""

    No descripton provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class ApivApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def connect_delete_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect DELETE requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_delete_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_delete_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect DELETE requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_delete_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_delete_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_delete_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_delete_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_delete_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_delete_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_delete_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect DELETE requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_delete_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_delete_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect DELETE requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_delete_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_delete_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_delete_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_delete_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_delete_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_delete_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_delete_node_proxy(self, Name, **kwargs):
        """
        connect DELETE requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_delete_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_delete_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect DELETE requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_delete_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_delete_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_delete_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_delete_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect DELETE requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_delete_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_delete_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_delete_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_delete_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_pod_attach(self, Namespace, Name, **kwargs):
        """
        connect GET requests to attach of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_attach(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
        :param bool Stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
        :param str Container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_pod_attach_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_get_namespaced_pod_attach_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_get_namespaced_pod_attach_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect GET requests to attach of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_attach_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
        :param bool Stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
        :param str Container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Stdin', 'Stdout', 'Stderr', 'Tty', 'Container']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_pod_attach" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_pod_attach`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_pod_attach`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/attach'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Stdin' in params:
            query_params['stdin'] = params['Stdin']
        if 'Stdout' in params:
            query_params['stdout'] = params['Stdout']
        if 'Stderr' in params:
            query_params['stderr'] = params['Stderr']
        if 'Tty' in params:
            query_params['tty'] = params['Tty']
        if 'Container' in params:
            query_params['container'] = params['Container']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_pod_exec(self, Namespace, Name, **kwargs):
        """
        connect GET requests to exec of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_exec(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Redirect the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Redirect the standard output stream of the pod for this call. Defaults to true.
        :param bool Stderr: Redirect the standard error stream of the pod for this call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
        :param str Container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :param str Command: Command is the remote command to execute. argv array. Not executed within a shell.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_pod_exec_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_get_namespaced_pod_exec_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_get_namespaced_pod_exec_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect GET requests to exec of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_exec_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Redirect the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Redirect the standard output stream of the pod for this call. Defaults to true.
        :param bool Stderr: Redirect the standard error stream of the pod for this call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
        :param str Container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :param str Command: Command is the remote command to execute. argv array. Not executed within a shell.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Stdin', 'Stdout', 'Stderr', 'Tty', 'Container', 'Command']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_pod_exec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_pod_exec`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_pod_exec`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/exec'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Stdin' in params:
            query_params['stdin'] = params['Stdin']
        if 'Stdout' in params:
            query_params['stdout'] = params['Stdout']
        if 'Stderr' in params:
            query_params['stderr'] = params['Stderr']
        if 'Tty' in params:
            query_params['tty'] = params['Tty']
        if 'Container' in params:
            query_params['container'] = params['Container']
        if 'Command' in params:
            query_params['command'] = params['Command']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_pod_portforward(self, Namespace, Name, **kwargs):
        """
        connect GET requests to portforward of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_portforward(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_pod_portforward_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_get_namespaced_pod_portforward_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_get_namespaced_pod_portforward_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect GET requests to portforward of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_portforward_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_pod_portforward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_pod_portforward`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_pod_portforward`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/portforward'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect GET requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_get_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_get_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect GET requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_get_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_get_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_get_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect GET requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_get_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_get_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect GET requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_get_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_get_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_get_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_get_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_node_proxy(self, Name, **kwargs):
        """
        connect GET requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_get_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_get_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect GET requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_get_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_get_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_get_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_get_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect GET requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_get_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_get_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_get_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect HEAD requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_head_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_head_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect HEAD requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_head_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_head_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_head_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_head_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_head_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect HEAD requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_head_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_head_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect HEAD requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_head_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_head_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_head_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_head_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_head_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_node_proxy(self, Name, **kwargs):
        """
        connect HEAD requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_head_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_head_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect HEAD requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_head_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_head_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_head_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_head_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect HEAD requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_head_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_head_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_head_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_head_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_options_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_options_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_options_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_options_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_options_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_options_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_options_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_options_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_options_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_options_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_options_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_options_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_options_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_options_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_node_proxy(self, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_options_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_options_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect OPTIONS requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_options_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_options_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_options_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_options_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect OPTIONS requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_options_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_options_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_options_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_options_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_pod_attach(self, Namespace, Name, **kwargs):
        """
        connect POST requests to attach of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_attach(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
        :param bool Stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
        :param str Container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_pod_attach_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_post_namespaced_pod_attach_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_post_namespaced_pod_attach_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect POST requests to attach of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_attach_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Stdin if true, redirects the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Stdout if true indicates that stdout is to be redirected for the attach call. Defaults to true.
        :param bool Stderr: Stderr if true indicates that stderr is to be redirected for the attach call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the attach call. This is passed through the container runtime so the tty is allocated on the worker node by the container runtime. Defaults to false.
        :param str Container: The container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Stdin', 'Stdout', 'Stderr', 'Tty', 'Container']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_pod_attach" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_pod_attach`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_pod_attach`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/attach'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Stdin' in params:
            query_params['stdin'] = params['Stdin']
        if 'Stdout' in params:
            query_params['stdout'] = params['Stdout']
        if 'Stderr' in params:
            query_params['stderr'] = params['Stderr']
        if 'Tty' in params:
            query_params['tty'] = params['Tty']
        if 'Container' in params:
            query_params['container'] = params['Container']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_pod_exec(self, Namespace, Name, **kwargs):
        """
        connect POST requests to exec of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_exec(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Redirect the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Redirect the standard output stream of the pod for this call. Defaults to true.
        :param bool Stderr: Redirect the standard error stream of the pod for this call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
        :param str Container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :param str Command: Command is the remote command to execute. argv array. Not executed within a shell.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_pod_exec_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_post_namespaced_pod_exec_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_post_namespaced_pod_exec_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect POST requests to exec of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_exec_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param bool Stdin: Redirect the standard input stream of the pod for this call. Defaults to false.
        :param bool Stdout: Redirect the standard output stream of the pod for this call. Defaults to true.
        :param bool Stderr: Redirect the standard error stream of the pod for this call. Defaults to true.
        :param bool Tty: TTY if true indicates that a tty will be allocated for the exec call. Defaults to false.
        :param str Container: Container in which to execute the command. Defaults to only container if there is only one container in the pod.
        :param str Command: Command is the remote command to execute. argv array. Not executed within a shell.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Stdin', 'Stdout', 'Stderr', 'Tty', 'Container', 'Command']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_pod_exec" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_pod_exec`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_pod_exec`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/exec'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Stdin' in params:
            query_params['stdin'] = params['Stdin']
        if 'Stdout' in params:
            query_params['stdout'] = params['Stdout']
        if 'Stderr' in params:
            query_params['stderr'] = params['Stderr']
        if 'Tty' in params:
            query_params['tty'] = params['Tty']
        if 'Container' in params:
            query_params['container'] = params['Container']
        if 'Command' in params:
            query_params['command'] = params['Command']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_pod_portforward(self, Namespace, Name, **kwargs):
        """
        connect POST requests to portforward of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_portforward(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_pod_portforward_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_post_namespaced_pod_portforward_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_post_namespaced_pod_portforward_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect POST requests to portforward of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_portforward_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_pod_portforward" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_pod_portforward`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_pod_portforward`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/portforward'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect POST requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_post_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_post_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect POST requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_post_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_post_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_post_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect POST requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_post_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_post_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect POST requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_post_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_post_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_post_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_post_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_node_proxy(self, Name, **kwargs):
        """
        connect POST requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_post_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_post_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect POST requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_post_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_post_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_post_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_post_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect POST requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_post_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_post_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_post_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_post_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_namespaced_pod_proxy(self, Namespace, Name, **kwargs):
        """
        connect PUT requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_pod_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_put_namespaced_pod_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_put_namespaced_pod_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect PUT requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_pod_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_namespaced_pod_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_put_namespaced_pod_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_namespaced_pod_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_namespaced_pod_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_pod_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_put_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_put_namespaced_pod_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_pod_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to pod.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_namespaced_pod_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_put_namespaced_pod_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_namespaced_pod_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_put_namespaced_pod_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_namespaced_service_proxy(self, Namespace, Name, **kwargs):
        """
        connect PUT requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_service_proxy(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.connect_put_namespaced_service_proxy_with_http_info(Namespace, Name, **kwargs)
            return data

    def connect_put_namespaced_service_proxy_with_http_info(self, Namespace, Name, **kwargs):
        """
        connect PUT requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_service_proxy_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_namespaced_service_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_put_namespaced_service_proxy`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_namespaced_service_proxy`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_namespaced_service_proxy_0(self, Namespace, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_service_proxy_0(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
        else:
            (data) = self.connect_put_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, **kwargs)
            return data

    def connect_put_namespaced_service_proxy_0_with_http_info(self, Namespace, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_namespaced_service_proxy_0_with_http_info(Namespace, Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the part of URLs that include service endpoints, suffixes, and parameters to use for the current proxy request to service. For example, the whole request URL is http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy. Path is _search?q=user:kimchy.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_namespaced_service_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `connect_put_namespaced_service_proxy_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_namespaced_service_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_put_namespaced_service_proxy_0`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_node_proxy(self, Name, **kwargs):
        """
        connect PUT requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_node_proxy(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_node_proxy_with_http_info(Name, **kwargs)
        else:
            (data) = self.connect_put_node_proxy_with_http_info(Name, **kwargs)
            return data

    def connect_put_node_proxy_with_http_info(self, Name, **kwargs):
        """
        connect PUT requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_node_proxy_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_node_proxy" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_node_proxy`")

        resource_path = '/api/v1/nodes/{name}/proxy'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def connect_put_node_proxy_0(self, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_node_proxy_0(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.connect_put_node_proxy_0_with_http_info(Name, Path2, **kwargs)
        else:
            (data) = self.connect_put_node_proxy_0_with_http_info(Name, Path2, **kwargs)
            return data

    def connect_put_node_proxy_0_with_http_info(self, Name, Path2, **kwargs):
        """
        connect PUT requests to proxy of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.connect_put_node_proxy_0_with_http_info(Name, Path2, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path2: path to the resource (required)
        :param str Path: Path is the URL path to use for the current proxy request to node.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path2', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_put_node_proxy_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `connect_put_node_proxy_0`")
        # verify the required parameter 'Path2' is set
        if ('Path2' not in params) or (params['Path2'] is None):
            raise ValueError("Missing the required parameter `Path2` when calling `connect_put_node_proxy_0`")

        resource_path = '/api/v1/nodes/{name}/proxy/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path2' in params:
            path_params['path'] = params['Path2']

        query_params = {}
        if 'Path' in params:
            query_params['path'] = params['Path']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespace(self, Body, **kwargs):
        """
        create a Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespace(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespace_with_http_info(Body, **kwargs)
        else:
            (data) = self.create_namespace_with_http_info(Body, **kwargs)
            return data

    def create_namespace_with_http_info(self, Body, **kwargs):
        """
        create a Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespace_with_http_info(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespace`")

        resource_path = '/api/v1/namespaces'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_binding(self, Body, Namespace, **kwargs):
        """
        create a Binding
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_binding(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Binding Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Binding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_binding_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_binding_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_binding_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Binding
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_binding_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Binding Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Binding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_binding`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_binding`")

        resource_path = '/api/v1/namespaces/{namespace}/bindings'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Binding',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_binding_binding(self, Body, Namespace, Name, **kwargs):
        """
        create binding of a Binding
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_binding_binding(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Binding Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Binding (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Binding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_binding_binding_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.create_namespaced_binding_binding_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def create_namespaced_binding_binding_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        create binding of a Binding
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_binding_binding_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Binding Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Binding (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Binding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_binding_binding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_binding_binding`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_binding_binding`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `create_namespaced_binding_binding`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/binding'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Binding',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_config_map(self, Body, Namespace, **kwargs):
        """
        create a ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_config_map(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ConfigMap Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_config_map_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_config_map_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_config_map_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_config_map_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ConfigMap Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_config_map`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_endpoints(self, Body, Namespace, **kwargs):
        """
        create a Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_endpoints(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Endpoints Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_endpoints_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_endpoints_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_endpoints_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_endpoints_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Endpoints Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_endpoints`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Endpoints',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_event(self, Body, Namespace, **kwargs):
        """
        create a Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_event(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Event Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_event_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_event_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_event_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_event_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Event Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_event`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Event',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_limit_range(self, Body, Namespace, **kwargs):
        """
        create a LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_limit_range(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1LimitRange Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_limit_range_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_limit_range_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_limit_range_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_limit_range_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1LimitRange Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_limit_range`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRange',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_persistent_volume_claim(self, Body, Namespace, **kwargs):
        """
        create a PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_persistent_volume_claim(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_persistent_volume_claim_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_pod(self, Body, Namespace, **kwargs):
        """
        create a Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_pod(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_pod_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_pod_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_pod_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_pod_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_pod`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_pod_template(self, Body, Namespace, **kwargs):
        """
        create a PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_pod_template(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PodTemplate Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_pod_template_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_pod_template_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_pod_template_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_pod_template_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PodTemplate Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_pod_template`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplate',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_replication_controller(self, Body, Namespace, **kwargs):
        """
        create a ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_replication_controller(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_replication_controller_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_replication_controller_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_replication_controller_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_replication_controller_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_replication_controller`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_resource_quota(self, Body, Namespace, **kwargs):
        """
        create a ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_resource_quota(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_resource_quota_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_resource_quota_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_resource_quota_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_resource_quota_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_resource_quota`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_secret(self, Body, Namespace, **kwargs):
        """
        create a Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_secret(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Secret Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_secret_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_secret_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_secret_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_secret_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Secret Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_secret`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Secret',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_service(self, Body, Namespace, **kwargs):
        """
        create a Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_service(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_service_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_service_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_service_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_service_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_service`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_namespaced_service_account(self, Body, Namespace, **kwargs):
        """
        create a ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_service_account(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ServiceAccount Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_namespaced_service_account_with_http_info(Body, Namespace, **kwargs)
        else:
            (data) = self.create_namespaced_service_account_with_http_info(Body, Namespace, **kwargs)
            return data

    def create_namespaced_service_account_with_http_info(self, Body, Namespace, **kwargs):
        """
        create a ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_namespaced_service_account_with_http_info(Body, Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ServiceAccount Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_namespaced_service_account`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `create_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_node(self, Body, **kwargs):
        """
        create a Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_node(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_node_with_http_info(Body, **kwargs)
        else:
            (data) = self.create_node_with_http_info(Body, **kwargs)
            return data

    def create_node_with_http_info(self, Body, **kwargs):
        """
        create a Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_node_with_http_info(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_node`")

        resource_path = '/api/v1/nodes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def create_persistent_volume(self, Body, **kwargs):
        """
        create a PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_persistent_volume(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.create_persistent_volume_with_http_info(Body, **kwargs)
        else:
            (data) = self.create_persistent_volume_with_http_info(Body, **kwargs)
            return data

    def create_persistent_volume_with_http_info(self, Body, **kwargs):
        """
        create a PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_persistent_volume_with_http_info(Body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `create_persistent_volume`")

        resource_path = '/api/v1/persistentvolumes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespace(self, Body, Name, **kwargs):
        """
        delete a Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespace(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespace_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.delete_namespace_with_http_info(Body, Name, **kwargs)
            return data

    def delete_namespace_with_http_info(self, Body, Name, **kwargs):
        """
        delete a Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespace_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespace`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespace`")

        resource_path = '/api/v1/namespaces/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_config_map(self, Body, Namespace, Name, **kwargs):
        """
        delete a ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_config_map(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_config_map_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_config_map_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_config_map`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_config_map`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_endpoints(self, Body, Namespace, Name, **kwargs):
        """
        delete a Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_endpoints(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_endpoints_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_endpoints_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_endpoints`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_endpoints`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_event(self, Body, Namespace, Name, **kwargs):
        """
        delete a Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_event(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_event_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_event_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_event`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_event`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_limit_range(self, Body, Namespace, Name, **kwargs):
        """
        delete a LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_limit_range(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_limit_range_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_limit_range_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_limit_range`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_limit_range`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_persistent_volume_claim(self, Body, Namespace, Name, **kwargs):
        """
        delete a PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_persistent_volume_claim(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_persistent_volume_claim_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_pod(self, Body, Namespace, Name, **kwargs):
        """
        delete a Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_pod(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_pod_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_pod_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_pod`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_pod_template(self, Body, Namespace, Name, **kwargs):
        """
        delete a PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_pod_template(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_pod_template_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_pod_template_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_pod_template`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_pod_template`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_replication_controller(self, Body, Namespace, Name, **kwargs):
        """
        delete a ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_replication_controller(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_replication_controller_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_replication_controller_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_replication_controller`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_replication_controller`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_resource_quota(self, Body, Namespace, Name, **kwargs):
        """
        delete a ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_resource_quota(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_resource_quota_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_resource_quota_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_resource_quota`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_resource_quota`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_secret(self, Body, Namespace, Name, **kwargs):
        """
        delete a Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_secret(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_secret_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_secret_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_secret`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_secret`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_service(self, Namespace, Name, **kwargs):
        """
        delete a Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def delete_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        delete a Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_namespaced_service_account(self, Body, Namespace, Name, **kwargs):
        """
        delete a ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_service_account(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.delete_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def delete_namespaced_service_account_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        delete a ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_namespaced_service_account_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_namespaced_service_account`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `delete_namespaced_service_account`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_node(self, Body, Name, **kwargs):
        """
        delete a Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_node(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_node_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.delete_node_with_http_info(Body, Name, **kwargs)
            return data

    def delete_node_with_http_info(self, Body, Name, **kwargs):
        """
        delete a Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_node_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_node`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_node`")

        resource_path = '/api/v1/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def delete_persistent_volume(self, Body, Name, **kwargs):
        """
        delete a PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_persistent_volume(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_persistent_volume_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.delete_persistent_volume_with_http_info(Body, Name, **kwargs)
            return data

    def delete_persistent_volume_with_http_info(self, Body, Name, **kwargs):
        """
        delete a PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_persistent_volume_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1DeleteOptions Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `delete_persistent_volume`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `delete_persistent_volume`")

        resource_path = '/api/v1/persistentvolumes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespace(self, **kwargs):
        """
        delete collection of Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespace(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespace_with_http_info(**kwargs)
        else:
            (data) = self.deletecollection_namespace_with_http_info(**kwargs)
            return data

    def deletecollection_namespace_with_http_info(self, **kwargs):
        """
        delete collection of Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespace_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespace" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/namespaces'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_config_map(self, Namespace, **kwargs):
        """
        delete collection of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_config_map(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_config_map_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_config_map_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_config_map_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_config_map_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_endpoints(self, Namespace, **kwargs):
        """
        delete collection of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_endpoints(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_endpoints_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_endpoints_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_endpoints_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_endpoints_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_event(self, Namespace, **kwargs):
        """
        delete collection of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_event(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_event_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_event_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_event_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_event_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_limit_range(self, Namespace, **kwargs):
        """
        delete collection of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_limit_range(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_limit_range_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_limit_range_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_limit_range_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_limit_range_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_persistent_volume_claim(self, Namespace, **kwargs):
        """
        delete collection of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_persistent_volume_claim(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_persistent_volume_claim_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_persistent_volume_claim_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_persistent_volume_claim_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_persistent_volume_claim_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_pod(self, Namespace, **kwargs):
        """
        delete collection of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_pod(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_pod_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_pod_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_pod_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_pod_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_pod_template(self, Namespace, **kwargs):
        """
        delete collection of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_pod_template(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_pod_template_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_pod_template_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_pod_template_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_pod_template_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_replication_controller(self, Namespace, **kwargs):
        """
        delete collection of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_replication_controller(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_replication_controller_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_replication_controller_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_replication_controller_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_replication_controller_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_resource_quota(self, Namespace, **kwargs):
        """
        delete collection of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_resource_quota(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_resource_quota_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_resource_quota_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_resource_quota_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_resource_quota_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_secret(self, Namespace, **kwargs):
        """
        delete collection of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_secret(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_secret_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_secret_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_secret_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_secret_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_namespaced_service_account(self, Namespace, **kwargs):
        """
        delete collection of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_service_account(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_namespaced_service_account_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.deletecollection_namespaced_service_account_with_http_info(Namespace, **kwargs)
            return data

    def deletecollection_namespaced_service_account_with_http_info(self, Namespace, **kwargs):
        """
        delete collection of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_namespaced_service_account_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `deletecollection_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_node(self, **kwargs):
        """
        delete collection of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_node(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_node_with_http_info(**kwargs)
        else:
            (data) = self.deletecollection_node_with_http_info(**kwargs)
            return data

    def deletecollection_node_with_http_info(self, **kwargs):
        """
        delete collection of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_node_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_node" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/nodes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def deletecollection_persistent_volume(self, **kwargs):
        """
        delete collection of PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_persistent_volume(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.deletecollection_persistent_volume_with_http_info(**kwargs)
        else:
            (data) = self.deletecollection_persistent_volume_with_http_info(**kwargs)
            return data

    def deletecollection_persistent_volume_with_http_info(self, **kwargs):
        """
        delete collection of PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.deletecollection_persistent_volume_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: UnversionedStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deletecollection_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/persistentvolumes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def get_api_resources(self, **kwargs):
        """
        get available resources
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_resources(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: UnversionedAPIResourceList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_api_resources_with_http_info(**kwargs)
        else:
            (data) = self.get_api_resources_with_http_info(**kwargs)
            return data

    def get_api_resources_with_http_info(self, **kwargs):
        """
        get available resources
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_api_resources_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :return: UnversionedAPIResourceList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_api_resources" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='UnversionedAPIResourceList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_component_status(self, **kwargs):
        """
        list objects of kind ComponentStatus
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_component_status(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ComponentStatusList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_component_status_with_http_info(**kwargs)
        else:
            (data) = self.list_component_status_with_http_info(**kwargs)
            return data

    def list_component_status_with_http_info(self, **kwargs):
        """
        list objects of kind ComponentStatus
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_component_status_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ComponentStatusList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_component_status" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/componentstatuses'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ComponentStatusList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespace(self, **kwargs):
        """
        list or watch objects of kind Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespace(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1NamespaceList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespace_with_http_info(**kwargs)
        else:
            (data) = self.list_namespace_with_http_info(**kwargs)
            return data

    def list_namespace_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespace_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1NamespaceList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespace" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/namespaces'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1NamespaceList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_config_map(self, **kwargs):
        """
        list or watch objects of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_config_map(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ConfigMapList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_config_map_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_config_map_with_http_info(**kwargs)
            return data

    def list_namespaced_config_map_with_http_info(self, **kwargs):
        """
        list or watch objects of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_config_map_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ConfigMapList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/configmaps'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMapList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_config_map_0(self, Namespace, **kwargs):
        """
        list or watch objects of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_config_map_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ConfigMapList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_config_map_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_config_map_0_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_config_map_0_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_config_map_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ConfigMapList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_config_map_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_config_map_0`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMapList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_endpoints(self, **kwargs):
        """
        list or watch objects of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_endpoints(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EndpointsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_endpoints_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_endpoints_with_http_info(**kwargs)
            return data

    def list_namespaced_endpoints_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_endpoints_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EndpointsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/endpoints'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1EndpointsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_endpoints_0(self, Namespace, **kwargs):
        """
        list or watch objects of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_endpoints_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EndpointsList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_endpoints_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_endpoints_0_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_endpoints_0_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_endpoints_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EndpointsList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_endpoints_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_endpoints_0`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1EndpointsList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_event(self, **kwargs):
        """
        list or watch objects of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_event(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EventList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_event_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_event_with_http_info(**kwargs)
            return data

    def list_namespaced_event_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_event_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EventList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/events'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1EventList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_event_0(self, Namespace, **kwargs):
        """
        list or watch objects of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_event_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EventList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_event_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_event_0_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_event_0_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_event_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1EventList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_event_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_event_0`")

        resource_path = '/api/v1/namespaces/{namespace}/events'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1EventList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_limit_range(self, **kwargs):
        """
        list or watch objects of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_limit_range(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1LimitRangeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_limit_range_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_limit_range_with_http_info(**kwargs)
            return data

    def list_namespaced_limit_range_with_http_info(self, **kwargs):
        """
        list or watch objects of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_limit_range_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1LimitRangeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/limitranges'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRangeList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_limit_range_0(self, Namespace, **kwargs):
        """
        list or watch objects of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_limit_range_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1LimitRangeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_limit_range_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_limit_range_0_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_limit_range_0_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_limit_range_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1LimitRangeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_limit_range_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_limit_range_0`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRangeList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_persistent_volume_claim(self, Namespace, **kwargs):
        """
        list or watch objects of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_persistent_volume_claim(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeClaimList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_persistent_volume_claim_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_persistent_volume_claim_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_persistent_volume_claim_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_persistent_volume_claim_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeClaimList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaimList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_persistent_volume_claim_0(self, **kwargs):
        """
        list or watch objects of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_persistent_volume_claim_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeClaimList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_persistent_volume_claim_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_persistent_volume_claim_0_with_http_info(**kwargs)
            return data

    def list_namespaced_persistent_volume_claim_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_persistent_volume_claim_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeClaimList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_persistent_volume_claim_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaimList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_pod(self, Namespace, **kwargs):
        """
        list or watch objects of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_pod_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_pod_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_pod_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_pod_0(self, **kwargs):
        """
        list or watch objects of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_pod_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_pod_0_with_http_info(**kwargs)
            return data

    def list_namespaced_pod_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/pods'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_pod_template(self, Namespace, **kwargs):
        """
        list or watch objects of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_template(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodTemplateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_pod_template_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_pod_template_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_pod_template_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_template_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodTemplateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplateList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_pod_template_0(self, **kwargs):
        """
        list or watch objects of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_template_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodTemplateList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_pod_template_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_pod_template_0_with_http_info(**kwargs)
            return data

    def list_namespaced_pod_template_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_pod_template_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PodTemplateList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_pod_template_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/podtemplates'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplateList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_replication_controller(self, Namespace, **kwargs):
        """
        list or watch objects of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_replication_controller(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ReplicationControllerList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_replication_controller_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_replication_controller_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_replication_controller_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_replication_controller_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ReplicationControllerList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationControllerList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_replication_controller_0(self, **kwargs):
        """
        list or watch objects of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_replication_controller_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ReplicationControllerList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_replication_controller_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_replication_controller_0_with_http_info(**kwargs)
            return data

    def list_namespaced_replication_controller_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_replication_controller_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ReplicationControllerList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_replication_controller_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationControllerList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_resource_quota(self, Namespace, **kwargs):
        """
        list or watch objects of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_resource_quota(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ResourceQuotaList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_resource_quota_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_resource_quota_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_resource_quota_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_resource_quota_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ResourceQuotaList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuotaList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_resource_quota_0(self, **kwargs):
        """
        list or watch objects of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_resource_quota_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ResourceQuotaList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_resource_quota_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_resource_quota_0_with_http_info(**kwargs)
            return data

    def list_namespaced_resource_quota_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_resource_quota_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ResourceQuotaList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_resource_quota_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/resourcequotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuotaList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_secret(self, Namespace, **kwargs):
        """
        list or watch objects of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_secret(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1SecretList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_secret_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_secret_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_secret_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_secret_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1SecretList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1SecretList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_secret_0(self, **kwargs):
        """
        list or watch objects of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_secret_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1SecretList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_secret_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_secret_0_with_http_info(**kwargs)
            return data

    def list_namespaced_secret_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_secret_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1SecretList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_secret_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/secrets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1SecretList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_service(self, Namespace, **kwargs):
        """
        list or watch objects of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_service_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_service_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_service_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_service_0(self, **kwargs):
        """
        list or watch objects of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_service_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_service_0_with_http_info(**kwargs)
            return data

    def list_namespaced_service_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/services'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_service_account(self, Namespace, **kwargs):
        """
        list or watch objects of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_account(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceAccountList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_service_account_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.list_namespaced_service_account_with_http_info(Namespace, **kwargs)
            return data

    def list_namespaced_service_account_with_http_info(self, Namespace, **kwargs):
        """
        list or watch objects of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_account_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceAccountList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `list_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccountList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_namespaced_service_account_0(self, **kwargs):
        """
        list or watch objects of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_account_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceAccountList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_namespaced_service_account_0_with_http_info(**kwargs)
        else:
            (data) = self.list_namespaced_service_account_0_with_http_info(**kwargs)
            return data

    def list_namespaced_service_account_0_with_http_info(self, **kwargs):
        """
        list or watch objects of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_namespaced_service_account_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1ServiceAccountList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_namespaced_service_account_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/serviceaccounts'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccountList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_node(self, **kwargs):
        """
        list or watch objects of kind Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_node(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1NodeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_node_with_http_info(**kwargs)
        else:
            (data) = self.list_node_with_http_info(**kwargs)
            return data

    def list_node_with_http_info(self, **kwargs):
        """
        list or watch objects of kind Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_node_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1NodeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_node" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/nodes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1NodeList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def list_persistent_volume(self, **kwargs):
        """
        list or watch objects of kind PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_persistent_volume(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.list_persistent_volume_with_http_info(**kwargs)
        else:
            (data) = self.list_persistent_volume_with_http_info(**kwargs)
            return data

    def list_persistent_volume_with_http_info(self, **kwargs):
        """
        list or watch objects of kind PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.list_persistent_volume_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: V1PersistentVolumeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/persistentvolumes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeList',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespace(self, Body, Name, **kwargs):
        """
        partially update the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespace(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespace_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_namespace_with_http_info(Body, Name, **kwargs)
            return data

    def patch_namespace_with_http_info(self, Body, Name, **kwargs):
        """
        partially update the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespace_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespace`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespace`")

        resource_path = '/api/v1/namespaces/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespace_status(self, Body, Name, **kwargs):
        """
        partially update status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespace_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespace_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_namespace_status_with_http_info(Body, Name, **kwargs)
            return data

    def patch_namespace_status_with_http_info(self, Body, Name, **kwargs):
        """
        partially update status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespace_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespace_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespace_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespace_status`")

        resource_path = '/api/v1/namespaces/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_config_map(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_config_map(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_config_map_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_config_map_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_config_map`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_config_map`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_endpoints(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_endpoints(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_endpoints_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_endpoints_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_endpoints`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_endpoints`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Endpoints',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_event(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_event(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_event_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_event_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_event`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_event`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Event',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_limit_range(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_limit_range(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_limit_range_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_limit_range_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_limit_range`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_limit_range`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRange',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_persistent_volume_claim(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_persistent_volume_claim(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_persistent_volume_claim_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_persistent_volume_claim_status(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_persistent_volume_claim_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_persistent_volume_claim_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_persistent_volume_claim_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_persistent_volume_claim_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_persistent_volume_claim_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_persistent_volume_claim_status`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_pod(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_pod_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_pod`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_pod_status(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_pod_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_pod_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_pod_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_pod_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_pod_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_pod_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_pod_status`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_pod_template(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod_template(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_pod_template_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_pod_template_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_pod_template`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_pod_template`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplate',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_replication_controller(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_replication_controller(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_replication_controller_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_replication_controller_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_replication_controller`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_replication_controller`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_replication_controller_status(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_replication_controller_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_replication_controller_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_replication_controller_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_replication_controller_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_replication_controller_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_replication_controller_status`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_resource_quota(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_resource_quota(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_resource_quota_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_resource_quota_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_resource_quota`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_resource_quota`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_resource_quota_status(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_resource_quota_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_resource_quota_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_resource_quota_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_resource_quota_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_resource_quota_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_resource_quota_status`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_scale_scale(self, Body, Namespace, Name, **kwargs):
        """
        partially update scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_scale_scale(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_scale_scale_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_scale_scale_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_scale_scale_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_scale_scale_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_scale_scale" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_scale_scale`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_scale_scale`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_scale_scale`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Scale',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_secret(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_secret(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_secret_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_secret_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_secret`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_secret`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Secret',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_service(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_service_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_service_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_service_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_service`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_service_account(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service_account(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_service_account_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service_account_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_service_account`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_service_account`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_namespaced_service_status(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_namespaced_service_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.patch_namespaced_service_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def patch_namespaced_service_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        partially update status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_namespaced_service_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_namespaced_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_namespaced_service_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `patch_namespaced_service_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_namespaced_service_status`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_node(self, Body, Name, **kwargs):
        """
        partially update the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_node(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_node_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_node_with_http_info(Body, Name, **kwargs)
            return data

    def patch_node_with_http_info(self, Body, Name, **kwargs):
        """
        partially update the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_node_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_node`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_node`")

        resource_path = '/api/v1/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_node_status(self, Body, Name, **kwargs):
        """
        partially update status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_node_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_node_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_node_status_with_http_info(Body, Name, **kwargs)
            return data

    def patch_node_status_with_http_info(self, Body, Name, **kwargs):
        """
        partially update status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_node_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_node_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_node_status`")

        resource_path = '/api/v1/nodes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_persistent_volume(self, Body, Name, **kwargs):
        """
        partially update the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_persistent_volume(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_persistent_volume_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_persistent_volume_with_http_info(Body, Name, **kwargs)
            return data

    def patch_persistent_volume_with_http_info(self, Body, Name, **kwargs):
        """
        partially update the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_persistent_volume_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_persistent_volume`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_persistent_volume`")

        resource_path = '/api/v1/persistentvolumes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def patch_persistent_volume_status(self, Body, Name, **kwargs):
        """
        partially update status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_persistent_volume_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.patch_persistent_volume_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.patch_persistent_volume_status_with_http_info(Body, Name, **kwargs)
            return data

    def patch_persistent_volume_status_with_http_info(self, Body, Name, **kwargs):
        """
        partially update status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.patch_persistent_volume_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param UnversionedPatch Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_persistent_volume_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `patch_persistent_volume_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `patch_persistent_volume_status`")

        resource_path = '/api/v1/persistentvolumes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json-patch+json', 'application/merge-patch+json', 'application/strategic-merge-patch+json'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PATCH',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy DELETE requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_delete_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_delete_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy DELETE requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_delete_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy DELETE requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_delete_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_delete_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy DELETE requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_delete_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_delete_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy DELETE requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_delete_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_delete_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy DELETE requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_delete_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy DELETE requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_delete_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_delete_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy DELETE requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_delete_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_delete_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_node(self, Name, **kwargs):
        """
        proxy DELETE requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_delete_node_with_http_info(Name, **kwargs)
            return data

    def proxy_delete_node_with_http_info(self, Name, **kwargs):
        """
        proxy DELETE requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_delete_node_0(self, Name, Path, **kwargs):
        """
        proxy DELETE requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_delete_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_delete_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_delete_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy DELETE requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_delete_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_delete_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_delete_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_delete_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'DELETE',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy GET requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_get_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_get_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy GET requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_get_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy GET requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_get_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_get_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy GET requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_get_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_get_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy GET requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_get_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_get_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy GET requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_get_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy GET requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_get_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_get_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy GET requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_get_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_get_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_node(self, Name, **kwargs):
        """
        proxy GET requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_get_node_with_http_info(Name, **kwargs)
            return data

    def proxy_get_node_with_http_info(self, Name, **kwargs):
        """
        proxy GET requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_get_node_0(self, Name, Path, **kwargs):
        """
        proxy GET requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_get_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_get_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_get_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy GET requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_get_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_get_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_get_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_get_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy HEAD requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_head_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_head_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy HEAD requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_head_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy HEAD requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_head_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_head_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy HEAD requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_head_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_head_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy HEAD requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_head_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_head_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy HEAD requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_head_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy HEAD requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_head_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_head_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy HEAD requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_head_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_head_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_node(self, Name, **kwargs):
        """
        proxy HEAD requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_head_node_with_http_info(Name, **kwargs)
            return data

    def proxy_head_node_with_http_info(self, Name, **kwargs):
        """
        proxy HEAD requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_head_node_0(self, Name, Path, **kwargs):
        """
        proxy HEAD requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_head_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_head_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_head_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy HEAD requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_head_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_head_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_head_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_head_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'HEAD',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy OPTIONS requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_options_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_options_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy OPTIONS requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_options_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_options_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_options_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_options_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_options_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy OPTIONS requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_options_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_options_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy OPTIONS requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_options_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_options_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_options_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_options_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_options_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_node(self, Name, **kwargs):
        """
        proxy OPTIONS requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_options_node_with_http_info(Name, **kwargs)
            return data

    def proxy_options_node_with_http_info(self, Name, **kwargs):
        """
        proxy OPTIONS requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_options_node_0(self, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_options_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_options_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_options_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy OPTIONS requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_options_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_options_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_options_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_options_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'OPTIONS',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy POST requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_post_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_post_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy POST requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_post_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy POST requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_post_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_post_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy POST requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_post_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_post_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy POST requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_post_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_post_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy POST requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_post_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy POST requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_post_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_post_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy POST requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_post_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_post_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_node(self, Name, **kwargs):
        """
        proxy POST requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_post_node_with_http_info(Name, **kwargs)
            return data

    def proxy_post_node_with_http_info(self, Name, **kwargs):
        """
        proxy POST requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_post_node_0(self, Name, Path, **kwargs):
        """
        proxy POST requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_post_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_post_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_post_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy POST requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_post_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_post_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_post_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_post_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        proxy PUT requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_put_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_put_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy PUT requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_put_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_namespaced_pod`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_namespaced_pod_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy PUT requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_pod_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_put_namespaced_pod_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_put_namespaced_pod_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy PUT requests to Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_pod_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_namespaced_pod_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_put_namespaced_pod_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_namespaced_pod_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_put_namespaced_pod_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/pods/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_namespaced_service(self, Namespace, Name, **kwargs):
        """
        proxy PUT requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.proxy_put_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def proxy_put_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        proxy PUT requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_put_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_namespaced_service`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_namespaced_service_0(self, Namespace, Name, Path, **kwargs):
        """
        proxy PUT requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_service_0(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
        else:
            (data) = self.proxy_put_namespaced_service_0_with_http_info(Namespace, Name, Path, **kwargs)
            return data

    def proxy_put_namespaced_service_0_with_http_info(self, Namespace, Name, Path, **kwargs):
        """
        proxy PUT requests to Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_namespaced_service_0_with_http_info(Namespace, Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_namespaced_service_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `proxy_put_namespaced_service_0`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_namespaced_service_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_put_namespaced_service_0`")

        resource_path = '/api/v1/proxy/namespaces/{namespace}/services/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_node(self, Name, **kwargs):
        """
        proxy PUT requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.proxy_put_node_with_http_info(Name, **kwargs)
            return data

    def proxy_put_node_with_http_info(self, Name, **kwargs):
        """
        proxy PUT requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_node`")

        resource_path = '/api/v1/proxy/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def proxy_put_node_0(self, Name, Path, **kwargs):
        """
        proxy PUT requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_node_0(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.proxy_put_node_0_with_http_info(Name, Path, **kwargs)
        else:
            (data) = self.proxy_put_node_0_with_http_info(Name, Path, **kwargs)
            return data

    def proxy_put_node_0_with_http_info(self, Name, Path, **kwargs):
        """
        proxy PUT requests to Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.proxy_put_node_0_with_http_info(Name, Path, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Path: path to the resource (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Path']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method proxy_put_node_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `proxy_put_node_0`")
        # verify the required parameter 'Path' is set
        if ('Path' not in params) or (params['Path'] is None):
            raise ValueError("Missing the required parameter `Path` when calling `proxy_put_node_0`")

        resource_path = '/api/v1/proxy/nodes/{name}/{path}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']
        if 'Path' in params:
            path_params['path'] = params['Path']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['*/*'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_component_status(self, Name, **kwargs):
        """
        read the specified ComponentStatus
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_component_status(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the ComponentStatus (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ComponentStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_component_status_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_component_status_with_http_info(Name, **kwargs)
            return data

    def read_component_status_with_http_info(self, Name, **kwargs):
        """
        read the specified ComponentStatus
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_component_status_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the ComponentStatus (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ComponentStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_component_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_component_status`")

        resource_path = '/api/v1/componentstatuses/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ComponentStatus',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespace(self, Name, **kwargs):
        """
        read the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespace(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespace_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_namespace_with_http_info(Name, **kwargs)
            return data

    def read_namespace_with_http_info(self, Name, **kwargs):
        """
        read the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespace_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespace`")

        resource_path = '/api/v1/namespaces/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespace_status(self, Name, **kwargs):
        """
        read status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespace_status(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespace_status_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_namespace_status_with_http_info(Name, **kwargs)
            return data

    def read_namespace_status_with_http_info(self, Name, **kwargs):
        """
        read status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespace_status_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespace_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespace_status`")

        resource_path = '/api/v1/namespaces/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_config_map(self, Namespace, Name, **kwargs):
        """
        read the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_config_map(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_config_map_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_config_map_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_config_map_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_config_map_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_config_map`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_endpoints(self, Namespace, Name, **kwargs):
        """
        read the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_endpoints(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_endpoints_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_endpoints_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_endpoints_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_endpoints_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_endpoints`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Endpoints',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_event(self, Namespace, Name, **kwargs):
        """
        read the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_event(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_event_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_event_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_event_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_event_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_event`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Event',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_limit_range(self, Namespace, Name, **kwargs):
        """
        read the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_limit_range(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_limit_range_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_limit_range_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_limit_range_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_limit_range_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_limit_range`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRange',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_persistent_volume_claim(self, Namespace, Name, **kwargs):
        """
        read the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_persistent_volume_claim(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_persistent_volume_claim_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_persistent_volume_claim_status(self, Namespace, Name, **kwargs):
        """
        read status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_persistent_volume_claim_status(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_persistent_volume_claim_status_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_persistent_volume_claim_status_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_persistent_volume_claim_status_with_http_info(self, Namespace, Name, **kwargs):
        """
        read status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_persistent_volume_claim_status_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_persistent_volume_claim_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_persistent_volume_claim_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_persistent_volume_claim_status`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        read the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_pod_log(self, Namespace, Name, **kwargs):
        """
        read log of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_log(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str Container: The container for which to stream logs. Defaults to only container if there is one container in the pod.
        :param bool Follow: Follow the log stream of the pod. Defaults to false.
        :param bool Previous: Return previous terminated container logs. Defaults to false.
        :param int SinceSeconds: A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
        :param str SinceTime: An RFC3339 timestamp from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
        :param bool Timestamps: If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
        :param int TailLines: If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
        :param int LimitBytes: If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_pod_log_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_pod_log_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_pod_log_with_http_info(self, Namespace, Name, **kwargs):
        """
        read log of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_log_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str Container: The container for which to stream logs. Defaults to only container if there is one container in the pod.
        :param bool Follow: Follow the log stream of the pod. Defaults to false.
        :param bool Previous: Return previous terminated container logs. Defaults to false.
        :param int SinceSeconds: A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
        :param str SinceTime: An RFC3339 timestamp from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified.
        :param bool Timestamps: If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false.
        :param int TailLines: If set, the number of lines from the end of the logs to show. If not specified, logs are shown from the creation of the container or sinceSeconds or sinceTime
        :param int LimitBytes: If set, the number of bytes to read from the server before terminating the log output. This may not display a complete final line of logging, and may return slightly more or slightly less than the specified limit.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Container', 'Follow', 'Previous', 'SinceSeconds', 'SinceTime', 'Timestamps', 'TailLines', 'LimitBytes']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_pod_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_pod_log`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_pod_log`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/log'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Container' in params:
            query_params['container'] = params['Container']
        if 'Follow' in params:
            query_params['follow'] = params['Follow']
        if 'Previous' in params:
            query_params['previous'] = params['Previous']
        if 'SinceSeconds' in params:
            query_params['sinceSeconds'] = params['SinceSeconds']
        if 'SinceTime' in params:
            query_params['sinceTime'] = params['SinceTime']
        if 'Timestamps' in params:
            query_params['timestamps'] = params['Timestamps']
        if 'TailLines' in params:
            query_params['tailLines'] = params['TailLines']
        if 'LimitBytes' in params:
            query_params['limitBytes'] = params['LimitBytes']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_pod_status(self, Namespace, Name, **kwargs):
        """
        read status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_status(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_pod_status_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_pod_status_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_pod_status_with_http_info(self, Namespace, Name, **kwargs):
        """
        read status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_status_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_pod_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_pod_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_pod_status`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_pod_template(self, Namespace, Name, **kwargs):
        """
        read the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_template(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_pod_template_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_pod_template_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_pod_template_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_pod_template_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_pod_template`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplate',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_replication_controller(self, Namespace, Name, **kwargs):
        """
        read the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_replication_controller(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_replication_controller_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_replication_controller_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_replication_controller_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_replication_controller_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_replication_controller`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_replication_controller_status(self, Namespace, Name, **kwargs):
        """
        read status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_replication_controller_status(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_replication_controller_status_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_replication_controller_status_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_replication_controller_status_with_http_info(self, Namespace, Name, **kwargs):
        """
        read status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_replication_controller_status_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_replication_controller_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_replication_controller_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_replication_controller_status`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_resource_quota(self, Namespace, Name, **kwargs):
        """
        read the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_resource_quota(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_resource_quota_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_resource_quota_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_resource_quota_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_resource_quota_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_resource_quota`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_resource_quota_status(self, Namespace, Name, **kwargs):
        """
        read status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_resource_quota_status(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_resource_quota_status_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_resource_quota_status_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_resource_quota_status_with_http_info(self, Namespace, Name, **kwargs):
        """
        read status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_resource_quota_status_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_resource_quota_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_resource_quota_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_resource_quota_status`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_scale_scale(self, Namespace, Name, **kwargs):
        """
        read scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_scale_scale(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_scale_scale_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_scale_scale_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_scale_scale_with_http_info(self, Namespace, Name, **kwargs):
        """
        read scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_scale_scale_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_scale_scale" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_scale_scale`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_scale_scale`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Scale',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_secret(self, Namespace, Name, **kwargs):
        """
        read the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_secret(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_secret_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_secret_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_secret_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_secret_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_secret`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Secret',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_service(self, Namespace, Name, **kwargs):
        """
        read the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_service_account(self, Namespace, Name, **kwargs):
        """
        read the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service_account(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_service_account_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_service_account_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_service_account_with_http_info(self, Namespace, Name, **kwargs):
        """
        read the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service_account_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_service_account`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_namespaced_service_status(self, Namespace, Name, **kwargs):
        """
        read status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service_status(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_namespaced_service_status_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.read_namespaced_service_status_with_http_info(Namespace, Name, **kwargs)
            return data

    def read_namespaced_service_status_with_http_info(self, Namespace, Name, **kwargs):
        """
        read status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_namespaced_service_status_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_namespaced_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `read_namespaced_service_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_namespaced_service_status`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_node(self, Name, **kwargs):
        """
        read the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_node_with_http_info(Name, **kwargs)
            return data

    def read_node_with_http_info(self, Name, **kwargs):
        """
        read the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_node`")

        resource_path = '/api/v1/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_node_status(self, Name, **kwargs):
        """
        read status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_node_status(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_node_status_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_node_status_with_http_info(Name, **kwargs)
            return data

    def read_node_status_with_http_info(self, Name, **kwargs):
        """
        read status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_node_status_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_node_status`")

        resource_path = '/api/v1/nodes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_persistent_volume(self, Name, **kwargs):
        """
        read the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_persistent_volume(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_persistent_volume_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_persistent_volume_with_http_info(Name, **kwargs)
            return data

    def read_persistent_volume_with_http_info(self, Name, **kwargs):
        """
        read the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_persistent_volume_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param bool Export: Should this value be exported.  Export strips fields that a user can not specify.
        :param bool Exact: Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'Export', 'Exact']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_persistent_volume`")

        resource_path = '/api/v1/persistentvolumes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'Export' in params:
            query_params['export'] = params['Export']
        if 'Exact' in params:
            query_params['exact'] = params['Exact']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def read_persistent_volume_status(self, Name, **kwargs):
        """
        read status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_persistent_volume_status(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.read_persistent_volume_status_with_http_info(Name, **kwargs)
        else:
            (data) = self.read_persistent_volume_status_with_http_info(Name, **kwargs)
            return data

    def read_persistent_volume_status_with_http_info(self, Name, **kwargs):
        """
        read status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.read_persistent_volume_status_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method read_persistent_volume_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `read_persistent_volume_status`")

        resource_path = '/api/v1/persistentvolumes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespace(self, Body, Name, **kwargs):
        """
        replace the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespace_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_namespace_with_http_info(Body, Name, **kwargs)
            return data

    def replace_namespace_with_http_info(self, Body, Name, **kwargs):
        """
        replace the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespace`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespace`")

        resource_path = '/api/v1/namespaces/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespace_finalize(self, Body, Name, **kwargs):
        """
        replace finalize of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace_finalize(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespace_finalize_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_namespace_finalize_with_http_info(Body, Name, **kwargs)
            return data

    def replace_namespace_finalize_with_http_info(self, Body, Name, **kwargs):
        """
        replace finalize of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace_finalize_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespace_finalize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespace_finalize`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespace_finalize`")

        resource_path = '/api/v1/namespaces/{name}/finalize'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespace_status(self, Body, Name, **kwargs):
        """
        replace status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespace_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_namespace_status_with_http_info(Body, Name, **kwargs)
            return data

    def replace_namespace_status_with_http_info(self, Body, Name, **kwargs):
        """
        replace status of the specified Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespace_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Namespace Body:  (required)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Namespace
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespace_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespace_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespace_status`")

        resource_path = '/api/v1/namespaces/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Namespace',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_config_map(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_config_map(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ConfigMap Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_config_map_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_config_map_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_config_map_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ConfigMap Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ConfigMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_config_map`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_config_map`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_config_map`")

        resource_path = '/api/v1/namespaces/{namespace}/configmaps/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ConfigMap',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_endpoints(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_endpoints(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Endpoints Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_endpoints_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_endpoints_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_endpoints_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Endpoints Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Endpoints
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_endpoints`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_endpoints`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_endpoints`")

        resource_path = '/api/v1/namespaces/{namespace}/endpoints/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Endpoints',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_event(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_event(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Event Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_event_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_event_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_event_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Event Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Event
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_event`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_event`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_event`")

        resource_path = '/api/v1/namespaces/{namespace}/events/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Event',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_limit_range(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_limit_range(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1LimitRange Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_limit_range_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_limit_range_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_limit_range_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1LimitRange Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1LimitRange
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_limit_range`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_limit_range`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_limit_range`")

        resource_path = '/api/v1/namespaces/{namespace}/limitranges/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1LimitRange',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_persistent_volume_claim(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_persistent_volume_claim(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_persistent_volume_claim_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_persistent_volume_claim_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_persistent_volume_claim_status(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_persistent_volume_claim_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_persistent_volume_claim_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_persistent_volume_claim_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolumeClaim Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolumeClaim
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_persistent_volume_claim_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_persistent_volume_claim_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_persistent_volume_claim_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_persistent_volume_claim_status`")

        resource_path = '/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolumeClaim',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_pod(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_pod_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_pod_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_pod`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_pod`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_pod_status(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_pod_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_pod_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_pod_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Pod Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Pod
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_pod_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_pod_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_pod_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_pod_status`")

        resource_path = '/api/v1/namespaces/{namespace}/pods/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Pod',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_pod_template(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod_template(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PodTemplate Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_pod_template_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_pod_template_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_pod_template_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PodTemplate Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PodTemplate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_pod_template`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_pod_template`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_pod_template`")

        resource_path = '/api/v1/namespaces/{namespace}/podtemplates/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PodTemplate',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_replication_controller(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_replication_controller(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_replication_controller_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_replication_controller_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_replication_controller_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_replication_controller`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_replication_controller`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_replication_controller`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_replication_controller_status(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_replication_controller_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_replication_controller_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_replication_controller_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ReplicationController Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ReplicationController
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_replication_controller_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_replication_controller_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_replication_controller_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_replication_controller_status`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ReplicationController',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_resource_quota(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_resource_quota(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_resource_quota_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_resource_quota_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_resource_quota_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_resource_quota`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_resource_quota`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_resource_quota`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_resource_quota_status(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_resource_quota_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_resource_quota_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_resource_quota_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ResourceQuota Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ResourceQuota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_resource_quota_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_resource_quota_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_resource_quota_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_resource_quota_status`")

        resource_path = '/api/v1/namespaces/{namespace}/resourcequotas/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ResourceQuota',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_scale_scale(self, Body, Namespace, Name, **kwargs):
        """
        replace scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_scale_scale(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Scale Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_scale_scale_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_scale_scale_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_scale_scale_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace scale of the specified Scale
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_scale_scale_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Scale Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Scale (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Scale
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_scale_scale" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_scale_scale`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_scale_scale`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_scale_scale`")

        resource_path = '/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Scale',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_secret(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_secret(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Secret Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_secret_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_secret_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_secret_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Secret Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Secret
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_secret`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_secret`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_secret`")

        resource_path = '/api/v1/namespaces/{namespace}/secrets/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Secret',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_service(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_service_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_service_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_service_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_service`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_service`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_service_account(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service_account(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ServiceAccount Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_service_account_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_service_account_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace the specified ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service_account_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1ServiceAccount Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1ServiceAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_service_account`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_service_account`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_service_account`")

        resource_path = '/api/v1/namespaces/{namespace}/serviceaccounts/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1ServiceAccount',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_namespaced_service_status(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service_status(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_namespaced_service_status_with_http_info(Body, Namespace, Name, **kwargs)
        else:
            (data) = self.replace_namespaced_service_status_with_http_info(Body, Namespace, Name, **kwargs)
            return data

    def replace_namespaced_service_status_with_http_info(self, Body, Namespace, Name, **kwargs):
        """
        replace status of the specified Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_namespaced_service_status_with_http_info(Body, Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Service Body:  (required)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Namespace', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_namespaced_service_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_namespaced_service_status`")
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `replace_namespaced_service_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_namespaced_service_status`")

        resource_path = '/api/v1/namespaces/{namespace}/services/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Service',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_node(self, Body, Name, **kwargs):
        """
        replace the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_node(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_node_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_node_with_http_info(Body, Name, **kwargs)
            return data

    def replace_node_with_http_info(self, Body, Name, **kwargs):
        """
        replace the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_node_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_node`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_node`")

        resource_path = '/api/v1/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_node_status(self, Body, Name, **kwargs):
        """
        replace status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_node_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_node_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_node_status_with_http_info(Body, Name, **kwargs)
            return data

    def replace_node_status_with_http_info(self, Body, Name, **kwargs):
        """
        replace status of the specified Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_node_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1Node Body:  (required)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1Node
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_node_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_node_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_node_status`")

        resource_path = '/api/v1/nodes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1Node',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_persistent_volume(self, Body, Name, **kwargs):
        """
        replace the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_persistent_volume(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_persistent_volume_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_persistent_volume_with_http_info(Body, Name, **kwargs)
            return data

    def replace_persistent_volume_with_http_info(self, Body, Name, **kwargs):
        """
        replace the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_persistent_volume_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_persistent_volume`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_persistent_volume`")

        resource_path = '/api/v1/persistentvolumes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def replace_persistent_volume_status(self, Body, Name, **kwargs):
        """
        replace status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_persistent_volume_status(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.replace_persistent_volume_status_with_http_info(Body, Name, **kwargs)
        else:
            (data) = self.replace_persistent_volume_status_with_http_info(Body, Name, **kwargs)
            return data

    def replace_persistent_volume_status_with_http_info(self, Body, Name, **kwargs):
        """
        replace status of the specified PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.replace_persistent_volume_status_with_http_info(Body, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param V1PersistentVolume Body:  (required)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :return: V1PersistentVolume
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Body', 'Name', 'Pretty']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replace_persistent_volume_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Body' is set
        if ('Body' not in params) or (params['Body'] is None):
            raise ValueError("Missing the required parameter `Body` when calling `replace_persistent_volume_status`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `replace_persistent_volume_status`")

        resource_path = '/api/v1/persistentvolumes/{name}/status'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'Body' in params:
            body_params = params['Body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/yaml', 'application/vnd.kubernetes.protobuf'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'PUT',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='V1PersistentVolume',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespace(self, Name, **kwargs):
        """
        watch changes to an object of kind Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespace(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespace_with_http_info(Name, **kwargs)
        else:
            (data) = self.watch_namespace_with_http_info(Name, **kwargs)
            return data

    def watch_namespace_with_http_info(self, Name, **kwargs):
        """
        watch changes to an object of kind Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespace_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Namespace (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespace`")

        resource_path = '/api/v1/watch/namespaces/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespace_list(self, **kwargs):
        """
        watch individual changes to a list of Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespace_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespace_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespace_list_with_http_info(**kwargs)
            return data

    def watch_namespace_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Namespace
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespace_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespace_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/namespaces'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_config_map(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_config_map_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_config_map_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_config_map_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ConfigMap (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_config_map" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_config_map`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_config_map`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/configmaps/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_config_map_list(self, **kwargs):
        """
        watch individual changes to a list of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_config_map_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_config_map_list_with_http_info(**kwargs)
            return data

    def watch_namespaced_config_map_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_config_map_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/configmaps'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_config_map_list_0(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map_list_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_config_map_list_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_config_map_list_0_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_config_map_list_0_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ConfigMap
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_config_map_list_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_config_map_list_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_config_map_list_0`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/configmaps'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_endpoints(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_endpoints_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_endpoints_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_endpoints_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Endpoints (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_endpoints" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_endpoints`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_endpoints`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/endpoints/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_endpoints_list(self, **kwargs):
        """
        watch individual changes to a list of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_endpoints_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_endpoints_list_with_http_info(**kwargs)
            return data

    def watch_namespaced_endpoints_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_endpoints_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/endpoints'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_endpoints_list_0(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints_list_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_endpoints_list_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_endpoints_list_0_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_endpoints_list_0_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Endpoints
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_endpoints_list_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_endpoints_list_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_endpoints_list_0`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/endpoints'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_event(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_event_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_event_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_event_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Event (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_event`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_event`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/events/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_event_list(self, **kwargs):
        """
        watch individual changes to a list of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_event_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_event_list_with_http_info(**kwargs)
            return data

    def watch_namespaced_event_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_event_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/events'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_event_list_0(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event_list_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_event_list_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_event_list_0_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_event_list_0_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Event
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_event_list_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_event_list_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_event_list_0`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/events'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_limit_range(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_limit_range_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_limit_range_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_limit_range_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the LimitRange (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_limit_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_limit_range`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_limit_range`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/limitranges/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_limit_range_list(self, **kwargs):
        """
        watch individual changes to a list of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_limit_range_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_limit_range_list_with_http_info(**kwargs)
            return data

    def watch_namespaced_limit_range_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_limit_range_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/limitranges'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_limit_range_list_0(self, Namespace, **kwargs):
        """
        watch individual changes to a list of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range_list_0(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_limit_range_list_0_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_limit_range_list_0_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_limit_range_list_0_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of LimitRange
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_limit_range_list_0_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_limit_range_list_0" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_limit_range_list_0`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/limitranges'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_persistent_volume_claim(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_persistent_volume_claim_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PersistentVolumeClaim (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_persistent_volume_claim" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_persistent_volume_claim`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_persistent_volume_claim`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_persistent_volume_claim_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_persistent_volume_claim_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_persistent_volume_claim_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_persistent_volume_claim_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_persistent_volume_claim_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_persistent_volume_claim_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_persistent_volume_claim_list_0(self, **kwargs):
        """
        watch individual changes to a list of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_persistent_volume_claim_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_persistent_volume_claim_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_persistent_volume_claim_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of PersistentVolumeClaim
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_persistent_volume_claim_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_persistent_volume_claim_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/persistentvolumeclaims'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_pod_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_pod_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Pod (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_pod`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_pod`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/pods/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_pod_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_pod_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_pod_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/pods'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod_list_0(self, **kwargs):
        """
        watch individual changes to a list of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_pod_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_pod_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Pod
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/pods'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod_template(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_template_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_pod_template_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_pod_template_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the PodTemplate (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_pod_template`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_pod_template`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/podtemplates/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod_template_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_template_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_pod_template_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_pod_template_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod_template_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_pod_template_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/podtemplates'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_pod_template_list_0(self, **kwargs):
        """
        watch individual changes to a list of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_pod_template_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_pod_template_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_pod_template_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of PodTemplate
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_pod_template_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_pod_template_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/podtemplates'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_replication_controller(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_replication_controller_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_replication_controller_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_replication_controller_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ReplicationController (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_replication_controller" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_replication_controller`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_replication_controller`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_replication_controller_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_replication_controller_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_replication_controller_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_replication_controller_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_replication_controller_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_replication_controller_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_replication_controller_list_0(self, **kwargs):
        """
        watch individual changes to a list of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_replication_controller_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_replication_controller_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_replication_controller_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of ReplicationController
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_replication_controller_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_replication_controller_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/replicationcontrollers'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_resource_quota(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_resource_quota_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_resource_quota_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_resource_quota_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ResourceQuota (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_resource_quota" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_resource_quota`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_resource_quota`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_resource_quota_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_resource_quota_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_resource_quota_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_resource_quota_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_resource_quota_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_resource_quota_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/resourcequotas'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_resource_quota_list_0(self, **kwargs):
        """
        watch individual changes to a list of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_resource_quota_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_resource_quota_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_resource_quota_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of ResourceQuota
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_resource_quota_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_resource_quota_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/resourcequotas'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_secret(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_secret_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_secret_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_secret_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Secret (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_secret" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_secret`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_secret`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/secrets/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_secret_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_secret_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_secret_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_secret_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_secret_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_secret_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/secrets'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_secret_list_0(self, **kwargs):
        """
        watch individual changes to a list of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_secret_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_secret_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_secret_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Secret
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_secret_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_secret_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/secrets'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_service_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_service_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the Service (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_service`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_service`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/services/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service_account(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_account_with_http_info(Namespace, Name, **kwargs)
        else:
            (data) = self.watch_namespaced_service_account_with_http_info(Namespace, Name, **kwargs)
            return data

    def watch_namespaced_service_account_with_http_info(self, Namespace, Name, **kwargs):
        """
        watch changes to an object of kind ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account_with_http_info(Namespace, Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Name: name of the ServiceAccount (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_service_account`")
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_namespaced_service_account`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service_account_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_account_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_service_account_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_service_account_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service_account_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_service_account_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/serviceaccounts'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service_account_list_0(self, **kwargs):
        """
        watch individual changes to a list of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_account_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_service_account_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_service_account_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of ServiceAccount
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_account_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service_account_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/serviceaccounts'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service_list(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_list(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_list_with_http_info(Namespace, **kwargs)
        else:
            (data) = self.watch_namespaced_service_list_with_http_info(Namespace, **kwargs)
            return data

    def watch_namespaced_service_list_with_http_info(self, Namespace, **kwargs):
        """
        watch individual changes to a list of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_list_with_http_info(Namespace, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Namespace: object name and auth scope, such as for teams and projects (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Namespace', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Namespace' is set
        if ('Namespace' not in params) or (params['Namespace'] is None):
            raise ValueError("Missing the required parameter `Namespace` when calling `watch_namespaced_service_list`")

        resource_path = '/api/v1/watch/namespaces/{namespace}/services'.replace('{format}', 'json')
        path_params = {}
        if 'Namespace' in params:
            path_params['namespace'] = params['Namespace']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_namespaced_service_list_0(self, **kwargs):
        """
        watch individual changes to a list of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_list_0(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_namespaced_service_list_0_with_http_info(**kwargs)
        else:
            (data) = self.watch_namespaced_service_list_0_with_http_info(**kwargs)
            return data

    def watch_namespaced_service_list_0_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Service
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_namespaced_service_list_0_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_namespaced_service_list_0" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/services'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_node(self, Name, **kwargs):
        """
        watch changes to an object of kind Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_node(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_node_with_http_info(Name, **kwargs)
        else:
            (data) = self.watch_node_with_http_info(Name, **kwargs)
            return data

    def watch_node_with_http_info(self, Name, **kwargs):
        """
        watch changes to an object of kind Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_node_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the Node (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_node" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_node`")

        resource_path = '/api/v1/watch/nodes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_node_list(self, **kwargs):
        """
        watch individual changes to a list of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_node_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_node_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_node_list_with_http_info(**kwargs)
            return data

    def watch_node_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of Node
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_node_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_node_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/nodes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_persistent_volume(self, Name, **kwargs):
        """
        watch changes to an object of kind PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_persistent_volume(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_persistent_volume_with_http_info(Name, **kwargs)
        else:
            (data) = self.watch_persistent_volume_with_http_info(Name, **kwargs)
            return data

    def watch_persistent_volume_with_http_info(self, Name, **kwargs):
        """
        watch changes to an object of kind PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_persistent_volume_with_http_info(Name, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Name: name of the PersistentVolume (required)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Name', 'Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_persistent_volume" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'Name' is set
        if ('Name' not in params) or (params['Name'] is None):
            raise ValueError("Missing the required parameter `Name` when calling `watch_persistent_volume`")

        resource_path = '/api/v1/watch/persistentvolumes/{name}'.replace('{format}', 'json')
        path_params = {}
        if 'Name' in params:
            path_params['name'] = params['Name']

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))

    def watch_persistent_volume_list(self, **kwargs):
        """
        watch individual changes to a list of PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_persistent_volume_list(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.watch_persistent_volume_list_with_http_info(**kwargs)
        else:
            (data) = self.watch_persistent_volume_list_with_http_info(**kwargs)
            return data

    def watch_persistent_volume_list_with_http_info(self, **kwargs):
        """
        watch individual changes to a list of PersistentVolume
        

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.watch_persistent_volume_list_with_http_info(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str Pretty: If 'true', then the output is pretty printed.
        :param str LabelSelector: A selector to restrict the list of returned objects by their labels. Defaults to everything.
        :param str FieldSelector: A selector to restrict the list of returned objects by their fields. Defaults to everything.
        :param bool Watch: Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
        :param str ResourceVersion: When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
        :param int TimeoutSeconds: Timeout for the list/watch call.
        :return: VersionedEvent
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['Pretty', 'LabelSelector', 'FieldSelector', 'Watch', 'ResourceVersion', 'TimeoutSeconds']
        all_params.append('callback')
        all_params.append('_return_http_data_only')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method watch_persistent_volume_list" % key
                )
            params[key] = val
        del params['kwargs']

        resource_path = '/api/v1/watch/persistentvolumes'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'Pretty' in params:
            query_params['pretty'] = params['Pretty']
        if 'LabelSelector' in params:
            query_params['labelSelector'] = params['LabelSelector']
        if 'FieldSelector' in params:
            query_params['fieldSelector'] = params['FieldSelector']
        if 'Watch' in params:
            query_params['watch'] = params['Watch']
        if 'ResourceVersion' in params:
            query_params['resourceVersion'] = params['ResourceVersion']
        if 'TimeoutSeconds' in params:
            query_params['timeoutSeconds'] = params['TimeoutSeconds']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/json;stream=watch', 'application/vnd.kubernetes.protobuf', 'application/vnd.kubernetes.protobuf;stream=watch'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['*/*'])

        # Authentication setting
        auth_settings = []

        return self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='VersionedEvent',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'),
                                            _return_http_data_only=params.get('_return_http_data_only'))
